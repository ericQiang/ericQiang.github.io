<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MBR与GPT分区</title>
    <link href="/2024/05/22/MBR%E4%B8%8EGPT%E5%88%86%E5%8C%BA/"/>
    <url>/2024/05/22/MBR%E4%B8%8EGPT%E5%88%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="MBR与GPT分区"><a href="#MBR与GPT分区" class="headerlink" title="MBR与GPT分区"></a>MBR与GPT分区</h1><p>在调试STM32MP135通过SD启动裸机程序时，ROM引导程序会先检查SD卡是否是GPT分区。故了解了一下。</p><p><strong>MBR</strong>（Master Boot Record）位于磁盘的第一个扇区，总大小为512字节。下面是这512字节的详细分布及每个字节的含义：</p><ol><li><strong>主引导程序（Bootstrap Code）</strong>：<ul><li>字节 0-445：<ul><li>这446字节的区域用于存放主引导程序代码，负责初始化硬件、定位并加载操作系统的引导程序。（通常是默认的引导代码或留空）</li></ul></li></ul></li><li><strong>分区表（Partition Table）</strong>：<ul><li>字节 446-509：<ul><li>共有4个分区条目，每个条目16字节，共64字节。每个分区条目结构如下：<ul><li>字节 0：引导标志（Boot Indicator）<ul><li>0x80 表示活动分区</li><li>0x00 表示非活动分区</li></ul></li><li>字节 1-3：起始CHS地址（Starting CHS Address）<ul><li>起始柱面（Cylinder）、磁头（Head）、扇区（Sector）地址，用于兼容性表示分区的起始位置</li></ul></li><li>字节 4：分区类型（Partition Type）<ul><li>标识分区类型，例如0x07（NTFS），0x0B（FAT32），<strong>0xEE(GPT)</strong></li></ul></li><li>字节 5-7：结束CHS地址（Ending CHS Address）<ul><li>结束柱面、磁头、扇区地址，用于兼容性表示分区的结束位置</li></ul></li><li>字节 8-11：起始LBA地址（Starting LBA Address）<ul><li>使用逻辑块地址（LBA）表示分区的起始位置</li></ul></li><li>字节 12-15：分区大小（Size in Sectors）<ul><li>分区的总扇区数</li></ul></li></ul></li></ul></li></ul></li><li><strong>签名字段（Signature Field）</strong>：<ul><li>字节 510-511：<ul><li>固定值0x55AA，表示这是一个有效的MBR。如果这个签名不正确，系统通常会认为MBR损坏，无法正常引导。</li></ul></li></ul></li></ol><p>总结一下MBR的512字节详细结构：</p><ul><li><strong>字节 0-445</strong>：主引导程序代码（Bootstrap Code）</li><li><strong>字节 446-461</strong>：分区1的分区表条目</li><li><strong>字节 462-477</strong>：分区2的分区表条目</li><li><strong>字节 478-493</strong>：分区3的分区表条目</li><li><strong>字节 494-509</strong>：分区4的分区表条目</li><li><strong>字节 510-511</strong>：签名字段（0x55AA）</li></ul><p>具体来说，每个分区条目16字节的结构如下：</p><ul><li><strong>字节 0</strong>：引导标志（Boot Indicator）</li><li><strong>字节 1-3</strong>：起始CHS地址（Starting CHS Address）</li><li><strong>字节 4</strong>：分区类型（Partition Type）</li><li><strong>字节 5-7</strong>：结束CHS地址（Ending CHS Address）</li><li><strong>字节 8-11</strong>：起始LBA地址（Starting LBA Address）</li><li><strong>字节 12-15</strong>：分区大小（Size in Sectors）</li></ul><p>这些信息共同构成了MBR，帮助计算机识别和加载硬盘上的分区及其内容。</p><p>如果MBR分区表中的字节4（分区类型）为0xEE，这表示该分区是一个保护性MBR（Protective MBR），用于标识GPT（GUID Partition Table）分区。这是为了兼容旧系统和工具，它们可能无法识别GPT分区，但仍能够检测到磁盘的存在并避免破坏GPT分区表。</p><p>当MBR的分区类型为0xEE时，具体情况如下：</p><ol><li>保护性MBR（Protective MBR）：<ul><li><strong>起始LBA地址</strong>：通常为1，表示保护性MBR保护从第一个LBA开始的GPT分区表。</li><li><strong>分区大小</strong>：表示整个磁盘的大小，目的是确保旧的工具看到整个磁盘已经被占用，不会尝试对其进行重新分区。</li></ul></li></ol><p>保护性MBR的结构一般如下：</p><ul><li><strong>字节 0-445</strong>：主引导程序代码（通常是默认的引导代码或留空）</li><li><strong>字节 446-461</strong>：第一个分区条目，表示整个磁盘被GPT保护<ul><li><strong>字节 0</strong>：引导标志（Boot Indicator），通常为0x00</li><li><strong>字节 1-3</strong>：起始CHS地址（通常为0x000200，表示CHS的方式不可用）</li><li><strong>字节 4</strong>：分区类型（Partition Type），为0xEE，表示GPT保护分区</li><li><strong>字节 5-7</strong>：结束CHS地址（通常为0xFFFFFF，表示CHS的方式不可用）</li><li><strong>字节 8-11</strong>：起始LBA地址（Starting LBA Address），通常为1</li><li><strong>字节 12-15</strong>：分区大小（Size in Sectors），表示磁盘的总扇区数减1</li></ul></li><li><strong>字节 462-509</strong>：其余的三个分区条目，通常为空（全部为0）</li><li><strong>字节 510-511</strong>：签名字段（0x55AA）</li></ul><p>因此，MBR中分区类型为0xEE确实用来标识GPT分区，确保与旧系统和工具的兼容性，同时保护GPT结构不被无意覆盖。</p><p>在使用GPT（GUID Partition Table）分区的磁盘上，磁盘的布局和数据结构与传统的MBR（Master Boot Record）有所不同。GPT提供更灵活和强大的分区方案，支持更多分区以及更大的磁盘容量。GPT的结构分布如下：</p><ol><li><strong>保护性MBR（Protective MBR）</strong>：<ul><li>位于LBA 0，用于兼容旧系统，防止其误识别和破坏GPT磁盘。</li><li>保护性MBR中的分区类型为0xEE。</li></ul></li><li><strong>主GPT头（Primary GPT Header）</strong>：<ul><li>位于LBA 1，描述了GPT分区表的位置和结构。</li><li>结构如下：<ul><li><strong>签名（Signature）</strong>：8字节，固定值”EFI PART”（0x4546492050415254）。</li><li><strong>修订版本（Revision）</strong>：4字节，通常为0x00010000。</li><li><strong>头大小（Header Size）</strong>：4字节，通常为92字节。</li><li><strong>CRC32校验和（Header CRC32 Checksum）</strong>：4字节，用于校验头的完整性。</li><li><strong>备用头LBA（Backup LBA）</strong>：8字节，指向备份GPT头的位置。</li><li><strong>当前头LBA（Current LBA）</strong>：8字节，通常为1。</li><li><strong>分区表起始LBA（Partition Table Start LBA）</strong>：8字节，通常为2。</li><li><strong>分区条目数（Number of Partition Entries）</strong>：4字节，通常为128。</li><li><strong>每个分区条目大小（Size of Partition Entry）</strong>：4字节，通常为128字节。</li><li><strong>分区表CRC32校验和（Partition Table CRC32 Checksum）</strong>：4字节。</li></ul></li></ul></li><li><strong>主分区表（Primary Partition Table）</strong>：<ul><li>位于LBA 2开始，连续占用若干个LBA，用于描述各个分区。</li><li>每个分区条目128字节，默认支持128个分区，实际占用32个LBA（128*128字节&#x2F;512字节&#x3D;32 LBA）。</li><li>分区条目结构如下：<ul><li><strong>分区类型GUID（Partition Type GUID）</strong>：16字节，标识分区类型。</li><li><strong>分区GUID（Unique Partition GUID）</strong>：16字节，唯一标识分区。</li><li><strong>起始LBA（Starting LBA）</strong>：8字节，分区的起始位置。</li><li><strong>结束LBA（Ending LBA）</strong>：8字节，分区的结束位置。</li><li><strong>属性标志（Attributes）</strong>：8字节，分区属性。</li><li><strong>分区名称（Partition Name）</strong>：72字节，UTF-16LE编码的分区名称。</li></ul></li></ul></li><li><strong>分区数据区域（Partition Data Area）</strong>：<ul><li>从主分区表之后开始（通常是LBA 34），一直到备份分区表之前，用于存放实际的数据。</li></ul></li><li><strong>备份分区表（Backup Partition Table）</strong>：<ul><li>位于磁盘末端之前的若干LBA，与主分区表结构相同，用于数据恢复。</li></ul></li><li><strong>备份GPT头（Backup GPT Header）</strong>：<ul><li>位于磁盘的最后一个LBA，描述整个GPT布局，用于恢复主GPT头。</li></ul></li></ol><h3 id="举例：多个GPT分区的布局"><a href="#举例：多个GPT分区的布局" class="headerlink" title="举例：多个GPT分区的布局"></a>举例：多个GPT分区的布局</h3><p>假设有一个磁盘分成4个GPT分区，磁盘的逻辑布局如下：</p><ol><li><strong>LBA 0</strong>：保护性MBR</li><li><strong>LBA 1</strong>：主GPT头</li><li><strong>LBA 2-33</strong>：主分区表（包含128个分区条目，每个条目128字节）</li><li>**LBA 34-**：分区1数据</li><li><strong>LBA X</strong>：分区2数据</li><li><strong>LBA Y</strong>：分区3数据</li><li><strong>LBA Z</strong>：分区4数据</li><li><strong>备份分区表</strong>：位于磁盘末端之前的32个LBA</li><li><strong>备份GPT头</strong>：位于磁盘最后一个LBA</li></ol><p>这样，GPT提供了更灵活的分区方案，支持更多分区和更大的磁盘容量，同时通过备份头和分区表提高了数据的可靠性和恢复能力。</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小强学Python+OpenCV之－1.0开篇</title>
    <link href="/2024/01/13/%E5%B0%8F%E5%BC%BA%E5%AD%A6Python-OpenCV%E4%B9%8B%EF%BC%8D1-0%E5%BC%80%E7%AF%87/"/>
    <url>/2024/01/13/%E5%B0%8F%E5%BC%BA%E5%AD%A6Python-OpenCV%E4%B9%8B%EF%BC%8D1-0%E5%BC%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="小强学Python-OpenCV之－1-0开篇"><a href="#小强学Python-OpenCV之－1-0开篇" class="headerlink" title="小强学Python+OpenCV之－1.0开篇"></a>小强学Python+OpenCV之－1.0开篇</h1><h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>有没有想过使用Python + OpenCV来实现人脸识别？<br>想想就有点小兴奋吧。<br>小强也是不久前才了解到可以使用Python + OpenCV进行图像处理。觉得有趣就想学习一下。<br>在这里，把我学到的小知识记录一下，也为了自己以后方便查看。<br>也希望有相同兴趣的同学搭个伴，一起学习。更希望得到大牛们的指点和鼓励。</p><p>完成此课后，我设置的终极目标有下面几个：</p><p>1. </p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">实现停车场的车牌识别系统，并到天桥上去做实验<br></code></pre></td></tr></table></figure><p>2. </p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">手势识别？<br></code></pre></td></tr></table></figure><p>3. </p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">道路标线识别？自动驾驶？<br></code></pre></td></tr></table></figure><p>4. </p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">标志图形识别？跟踪？四轴飞行器？<br></code></pre></td></tr></table></figure><p>5. </p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">……发挥想像，一切和图像识别有关的东东<br></code></pre></td></tr></table></figure><p>6. </p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Deep learning?<br></code></pre></td></tr></table></figure><p>——————————————————华丽的分割线———————————————————</p><h2 id="下面进入正题。"><a href="#下面进入正题。" class="headerlink" title="下面进入正题。"></a>下面进入正题。</h2><p>编辑一个python脚本，取名为face_detect.py<br>键入以下内容并保存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入opencv库</span><br><span class="hljs-keyword">import</span> cv2<br> <br><span class="hljs-comment"># 加载图像</span><br>image = cv2.imread(<span class="hljs-string">&quot;messi.jpg&quot;</span>)<br> <br><span class="hljs-comment"># 显示我们的原始图像到屏幕上</span><br>cv2.imshow(<span class="hljs-string">&quot;Faces&quot;</span>, image)<br> <br><span class="hljs-comment"># 等待键盘输出</span><br>cv2.waitKey(<span class="hljs-number">0</span>)<br> <br><span class="hljs-comment"># 将图像转成灰度图像</span><br>gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)<br> <br><span class="hljs-comment"># 加载人脸分类检测器（这个分类检测器可以在opencv的安装路径xxx/OpenCV/haarcascade下找到）</span><br>detector =cv2.CascadeClassifier(<span class="hljs-string">&quot;haarcascade_frontalface_default.xml&quot;</span>)<br> <br><span class="hljs-comment"># 识别人脸，得到人脸所在的矩形区域（可能会得到多个人脸，所以这里是一个list）</span><br>rects = detector.detectMultiScale(gray,scaleFactor=<span class="hljs-number">1.05</span>, minNeighbors=<span class="hljs-number">7</span>,<br>         minSize=(<span class="hljs-number">30</span>,<span class="hljs-number">30</span>), flags=cv2.cv.CV_HAAR_SCALE_IMAGE)<br> <br><span class="hljs-comment"># 遍历list中每个识别到的人脸区域，并在原始图像上沿该区域的边界画一个颜色为绿色、线宽为2个像素的边框</span><br><span class="hljs-keyword">for</span> (x, y, w, h) <span class="hljs-keyword">in</span> rects:<br>         cv2.rectangle(image,(x, y), (x + w, y + h), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br> <br><span class="hljs-comment"># 将图像显示在屏幕上，</span><br>cv2.imshow(<span class="hljs-string">&quot;Faces&quot;</span>, image)<br> <br><span class="hljs-comment"># 等待键盘输出</span><br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>保存之后，在终端中执行python detect_faces.py<br>首先显示的是我们的原始图像。</p><img src="/2024/01/13/%E5%B0%8F%E5%BC%BA%E5%AD%A6Python-OpenCV%E4%B9%8B%EF%BC%8D1-0%E5%BC%80%E7%AF%87/messi1.jpg" srcset="/img/loading.gif" lazyload class=""><p>此时，按上键盘上的任意按键。</p><p>奇迹发生了。人脸识别出来了。</p><img src="/2024/01/13/%E5%B0%8F%E5%BC%BA%E5%AD%A6Python-OpenCV%E4%B9%8B%EF%BC%8D1-0%E5%BC%80%E7%AF%87/messi2.jpg" srcset="/img/loading.gif" lazyload class=""><p>是不是觉得很有趣？</p><p>话说回来。我们的路还长。这里只是给大家一个印象－好玩儿。毕竟兴趣才是最好的老师。</p><p>下面我会按部就班，完成以下内容（会慢慢补充）：</p><p>1.1. 图像的加载，显示和保存<br>1.2. 图像知识基础<br>1.3. 绘图<br>1.4. 基本图像处理<br>1.4.1 平移、旋转、缩放、翻转－之理论<br>1.4.2 裁剪<br>1.4.3 算术运算<br>1.4.4 掩膜(mask)及位运算<br>1.4.5 通道分离及合并<br>1.5. 内核（kernel）<br>1.6. 形态学图像处理（morphological operations）<br>1.7. 平滑模糊（smoothing and blurring）<br>1.8. 照明和颜色空间<br>1.9. 阈值<br>1.10. 梯度和边缘检测<br>a) 渐变<br>b) 边缘检测<br>1.11. 轮廓<br>a) 查找和绘制轮廓<br>b) 简单轮廓特性<br>c) 高级轮廓特性<br>d) 轮廓逼近<br>e) 轮廓排序<br>1.2. 柱状图<br>1.3. 连通区域标记</p><p>2.1. 什么是物体探测<br>a) 物体探测介绍<br>b) 模板匹配<br>2.2 物体探测<br>a) 安装dlib<br>b) 物体探测<br>2.3 ……</p>]]></content>
    
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>tags</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>categories</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
</search>
