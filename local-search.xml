<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>stm32mp135_裸机编程</title>
    <link href="/2024/05/22/stm32mp135-%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/05/22/stm32mp135-%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="stm32mp135-裸机编程"><a href="#stm32mp135-裸机编程" class="headerlink" title="stm32mp135 裸机编程"></a>stm32mp135 裸机编程</h1><h2 id="1-固件编译"><a href="#1-固件编译" class="headerlink" title="1.固件编译"></a>1.固件编译</h2><p>编译生成的elf文件需要增加一个stm32 header。这个header的添加是使用脚本工具实现的</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/Utilities/</span>ImageHeader/postbuild_STM32MP13.sh  <span class="hljs-string">&quot;$&#123;gnu_tools_for_stm32_compiler_path&#125;&quot;</span> <span class="hljs-string">&quot;$&#123;BuildArtifactFileBaseName&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>比如，裸机工程生成的固件为GPIO_EXTI_A7.elf，那么经过上面的命令后，生成的固件名为GPIO_EXTI_A7.stm32</p><h2 id="2-固件烧录"><a href="#2-固件烧录" class="headerlink" title="2.固件烧录"></a>2.固件烧录</h2><h3 id="烧录到spiflash中"><a href="#烧录到spiflash中" class="headerlink" title="烧录到spiflash中"></a>烧录到spiflash中</h3><p>将固件通过cube programmer烧录到spiflash中，烧录的tsv形如以下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">#Opt Id     Name        Type        IP      <span class="hljs-keyword">Offset</span>      <span class="hljs-type">Binary</span><br><span class="hljs-operator">-</span><span class="hljs-number">0x01</span>fsbl<span class="hljs-operator">-</span>boot<span class="hljs-type">Binary</span><span class="hljs-keyword">none</span><span class="hljs-number">0x0</span>.<span class="hljs-operator">/</span>tf<span class="hljs-operator">-</span>a<span class="hljs-operator">-</span>stm32mp135f<span class="hljs-operator">-</span>dk<span class="hljs-operator">-</span>usb.stm32<br><span class="hljs-operator">-</span><span class="hljs-number">0x03</span>fip<span class="hljs-operator">-</span>bootFIP<span class="hljs-keyword">none</span><span class="hljs-number">0x0</span>.<span class="hljs-operator">/</span>fip<span class="hljs-operator">-</span>stm32mp135f<span class="hljs-operator">-</span>dk<span class="hljs-operator">-</span>optee.bin<br>P<span class="hljs-number">0x04</span>fsbl1<span class="hljs-type">Binary</span>nor0<span class="hljs-number">0x00000000</span>.<span class="hljs-operator">/</span>pciem02_fsbl.stm32<br>P<span class="hljs-number">0x05</span>fsbl2<span class="hljs-type">Binary</span>nor0<span class="hljs-number">0x00040000</span>.<span class="hljs-operator">/</span>pciem02_app.stm32<br></code></pre></td></tr></table></figure><p>说明：上述0x01和0x03是usb烧录启动固件。0x01先通过cubeprogrammer烧入sysram中并运行（会初始化ddr），然后将0x03（其实是uboot）烧入ddr中，并运行。uboot中会通过usb烧录0x04和0x05分别烧入spiflash的偏移位置0和偏移位置0x00040000处。</p><p>当然，如果在量产阶段，也可以直接烧写spiflash，然后再进行SMT。</p><h3 id="烧录到SD卡中"><a href="#烧录到SD卡中" class="headerlink" title="烧录到SD卡中"></a>烧录到SD卡中</h3><p>在<a href="https://wiki.st.com/stm32mpu/wiki/STM32_MPU_ROM_code_overview">stm32mp135 wiki</a>中有如下描述：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">3.3</span><span class="hljs-number">.3</span> Boot <span class="hljs-built_in">from</span> SD card↑<br>SD cards contain <span class="hljs-literal">two</span> versions <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> FSBL. The ROM code tries <span class="hljs-built_in">to</span> <span class="hljs-built_in">load</span> <span class="hljs-keyword">and</span> launch <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> copy. In <span class="hljs-keyword">the</span> <span class="hljs-keyword">case</span> <span class="hljs-keyword">of</span> failure, <span class="hljs-keyword">it</span> <span class="hljs-keyword">then</span> tries <span class="hljs-built_in">to</span> <span class="hljs-built_in">load</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> copy.<br><br>The ROM code <span class="hljs-keyword">first</span> looks <span class="hljs-keyword">for</span> <span class="hljs-keyword">a</span> GPT. If <span class="hljs-keyword">it</span> finds <span class="hljs-keyword">it</span>, <span class="hljs-keyword">it</span> locates <span class="hljs-literal">two</span> FSBLs <span class="hljs-keyword">by</span> looking <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> <span class="hljs-literal">two</span> <span class="hljs-keyword">first</span> GPT entries <span class="hljs-keyword">of</span> which <span class="hljs-keyword">the</span> name <span class="hljs-keyword">begins</span> <span class="hljs-keyword">with</span> <span class="hljs-string">&quot;fsbl&quot;</span>. If <span class="hljs-keyword">it</span> cannot find <span class="hljs-keyword">a</span> GPT, <span class="hljs-keyword">the</span> ROM code looks <span class="hljs-keyword">for</span> FSBL1 <span class="hljs-keyword">at</span> <span class="hljs-built_in">offset</span> LBA128, <span class="hljs-keyword">and</span> FSBL2 <span class="hljs-keyword">at</span> <span class="hljs-built_in">offset</span> LBA640.<br></code></pre></td></tr></table></figure><p>上电后，ROM会先查找GPT分区，如果SD卡中有GPT分区，则检查GPT分区的entry name为fsbl开头的（比如fsbl1）。则从该分区读取固件（.stm32格式）到sysram中运行。</p><p>如果SD卡中并没有分区（或者有分区，但分区格式不是GPT（比如MBR）），则从SD卡的逻辑地址LBA128(因为SD卡的sector大小为512，即128*512＝64KB)处读取固件（.stm32格式）到sysram中运行。</p><p>注：wiki中的描述中，还有关于fsbl2的读取。目前我没有用到。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h4 id="linux下烧写固件到SD卡的64KB偏移处。"><a href="#linux下烧写固件到SD卡的64KB偏移处。" class="headerlink" title="linux下烧写固件到SD卡的64KB偏移处。"></a>linux下烧写固件到SD卡的64KB偏移处。</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=GPIO_EXTI_A7.stm32 <span class="hljs-attribute">of</span>=/dev/sdc <span class="hljs-attribute">bs</span>=512 <span class="hljs-attribute">seek</span>=128<br></code></pre></td></tr></table></figure><h4 id="linux下对SD卡进行分区"><a href="#linux下对SD卡进行分区" class="headerlink" title="linux下对SD卡进行分区"></a>linux下对SD卡进行分区</h4><ol><li><p>分区表设置为GPT（修改会导致分区丢失）</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cos">sudo parted /dev/sdc<span class="hljs-comment">//会进入parted命令交互界面</span><br><br>(parted) <span class="hljs-keyword">print</span><span class="hljs-comment">//在parted交互界面中打印当前分区表</span><br>(parted) mklabel gpt<span class="hljs-comment">//将分区表格式转换为GPT</span><br>(parted) <span class="hljs-keyword">quit</span><span class="hljs-comment">//退出</span><br></code></pre></td></tr></table></figure></li><li><p>重新分区</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">sudo</span> <span class="hljs-selector-tag">fdisk</span> /<span class="hljs-selector-tag">dev</span>/<span class="hljs-selector-tag">sdc</span><span class="hljs-comment">//进入fdisk命令交互界面</span><br>分别输入以下命令<br><span class="hljs-selector-tag">d</span><span class="hljs-comment">//删除已有分区</span><br><span class="hljs-selector-tag">n</span><span class="hljs-comment">//新建分区</span><br><span class="hljs-selector-tag">p</span><span class="hljs-comment">//选择主分区</span><br><span class="hljs-number">1</span><span class="hljs-comment">//创建第1个分区</span><br>回车 <span class="hljs-comment">//第一个分区起始位置，默认2048处</span><br>+<span class="hljs-number">256</span><span class="hljs-selector-tag">M</span><span class="hljs-comment">//第一个分区的大小选择为256MB</span><br><br><span class="hljs-selector-tag">n</span><span class="hljs-comment">//新建分区</span><br><span class="hljs-selector-tag">p</span><span class="hljs-comment">//选择主分区</span><br><span class="hljs-number">2</span><span class="hljs-comment">//创建第2个分区</span><br>回车 <span class="hljs-comment">//第2个分区起始位置，默认2048处</span><br>回车<span class="hljs-comment">//第2个分区的大小选择为剩余大小</span><br><br><span class="hljs-selector-tag">p</span><span class="hljs-comment">//打印当前分区情况</span><br><br><span class="hljs-selector-tag">w</span><span class="hljs-comment">//写入分区信息</span><br><br></code></pre></td></tr></table></figure></li><li><p>修改分区名称</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs q">sudo apt-<span class="hljs-built_in">get</span> install gdisk<span class="hljs-comment">//安装gdisk工具</span><br>sudo gdisk /<span class="hljs-built_in">dev</span>/sdc<span class="hljs-comment">//进入gdisk命令交互界面</span><br><br>输入以下命令：<br>c<span class="hljs-comment">//修改分区名称</span><br><span class="hljs-number">1</span><span class="hljs-comment">//输入分区编号</span><br>fsbl1<span class="hljs-comment">//输入分区名称</span><br>w<span class="hljs-comment">//写入分区信息</span><br><br>p<span class="hljs-comment">//打印当前分区情况，可以看到分区名称已经修改成功</span><br></code></pre></td></tr></table></figure></li><li><p>将GPIO_EXTI_A7.stm32固件烧入fsbl1分区</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=GPIO_EXTI_A7.stm32 <span class="hljs-attribute">of</span>=/dev/sdc1 <span class="hljs-attribute">bs</span>=512<br></code></pre></td></tr></table></figure></li><li><p>完成（插入SD卡，固件会自动加载并运行）</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>tags</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>分类</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
</search>
